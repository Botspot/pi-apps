#!/bin/bash

error() { #red text and exit 1
  echo -e "\e[91m$1\e[0m" 1>&2
  exit 1
}

if ! command -v yad &>/dev/null; then
  error "YAD needs to be installed to run Pi-Apps."
fi

#For systems with older versions of yad, the text color column cannot be left blank. This python script determines the default text color from GTK bindings.
if [ -z "${text_color+x}" ];then
  #0400 is the latest version
  yad_version="$(zcat /usr/share/doc/yad/NEWS.gz | head -n 1 | tr -cd '0123456789\n')"
  if [ $yad_version -lt 0400 ]; then
    text_color=$(echo "import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
from gi.repository import Gdk
win = Gtk.Window()
vb = Gtk.VBox()
tv = Gtk.TextView()
vb.add(tv)
win.show_all()
style = tv.get_style_context()
textcolor = style.get_color(Gtk.StateType.NORMAL)
print(Gdk.RGBA.to_string(textcolor))
" | python -)
  else
    text_color=""
  fi
fi
export text_color

terminal_manage() { #function to install/uninstall one app - uses a terminal and refreshes the app list
  if [ "$1" == 'uninstall' ];then
    action=uninstall
  elif [ "$1" == 'install' ];then
    action=install
  else
    error "terminal_manage(): Must specify an action: either 'install' or 'uninstall'"
  fi
  
  app="$2" #one app name
  
  #To prevent multiple simultaneous manage instances, use the 'daemon' mode. This will create a queue of actions that are executed concurrently.
  #The first daemon instance is the 'master' process. Subsequent processes will add the action to the queue and then exit.
  #All output is generated by the 'master' daemon process. Subsequent processes shouldn't open a terminal, because the master one is already open.
  if [ -f "${DIRECTORY}/data/manage-daemon/pid" ] && [ -e "/proc/$(cat "${DIRECTORY}/data/manage-daemon/pid")" ];then
    #The 'master' daemon is already running. Avoid launching a second terminal.
    "${DIRECTORY}/manage" daemon "$action $app"
    
  else
    #in a terminal, first get the api functions, display the pi-apps logo, run the manage script, and refresh the app list if the $pipe variable is set
    "${DIRECTORY}/etc/terminal-run" '
      DIRECTORY="'"$DIRECTORY"'"
      export geometry2="'"$geometry2"'"
      source "${DIRECTORY}/api"
      generate_logo
      
      refresh_list() { #Refresh the current list of apps in the event of a change
        if [ ! -z "'"$pipe"'" ];then
          echo -e "\f" > "'"$pipe"'"
          "${DIRECTORY}/preload" yad "'"$prefix"'" > "'"$pipe"'" 2>/dev/null
        fi
      }
      
      "${DIRECTORY}/manage" daemon "'"$action $app"'"
      
      #refresh app list
      refresh_list
      
      for i in {30..1} ;do
        echo -en "You can close this window now. Auto-closing in $i seconds.\e[0K\r"
        sleep 1
      done
      ' "Terminal Output"
    
  fi
}

#display first 4 arguments this script receives (for debugging)
if false;then
  echo "1 $1" 1>&2
  echo "2 $2" 1>&2
  echo "3 $3" 1>&2
  echo "4 $4" 1>&2
fi

#if this script runs itself with a 3rd argument, then yad used it.
if [ ! -z "$3" ];then
  input="$3" #the 3rd argument is the "sysname" column - invisible and used internally for scripts.
  
  echo "Selection: $input" 1>&2
  
  refresh_list() { #Refresh the current list of apps in the event of a change
    if [ ! -z "$pipe" ];then
      echo -e "\f" > "$pipe"
      "${DIRECTORY}/preload" yad "$prefix" > "$pipe" 2>/dev/null
    fi
  }
  
  if [[ "$input" == *'Updates/' ]];then
    #updater window
    
    "${DIRECTORY}/updater" gui fast $geometry2 --skip-taskbar --close-on-unfocus
    exitcode=$? #0 if update successful, 1 if list of updates was closed
    
    #figure out which prefix we are on and refresh the app list
    prefix="$(echo "$input" | sed 's+Updates/$++g')"
    
    if [ $exitcode == 0 ];then
      refresh_list
    fi
  elif [ "$input" == 'Search/' ];then
    #search window
    
    source "${DIRECTORY}/api" #to set the yadflags array variable
    
    app="$(yadflags+=("$geometry2") ; app_search_gui)"
    
    if [ ! -z "$app" ];then
      "${DIRECTORY}/gui" '' '' "$app" "$app"
    fi
    
  elif [[ "$input" == */ ]];then
    #app folder selected
    echo -e '\f' > $pipe #clear the yad list
    "${DIRECTORY}/preload" yad "${input::-1}" >> $pipe #send yad the app-list - derived from folder name but dropping the final slash character
    
  else #app details window
    
    #app is in format $prefix/$app, so split them out
    app="$(basename "$input")"
    prefix="$(dirname "$input")"
    
    #add status heading
    app_status="$(app_status "${app}")"
    
    #text to the right of the app icon
    abovetext="<b>$app</b> ($(sed 's/corrupted/corrupted - installation failed/g' <<<"$app_status" | sed 's/disabled/disabled - installation is prevented on your system/g'))"
    
    #If package-app, show what packages it installs
    if [ -f "${DIRECTORY}/apps/${app}/packages" ];then
      packages="$(cat "${DIRECTORY}/apps/${app}/packages")"
      if [ "$(wc -w <<<"$packages")" == 1 ];then
        #if package-app uses only 1 package, use singular case
        abovetext+=$'\n'"- This app installs the <b>${packages}</b> package."
      else
        #if package-app uses multiple packages, use plural case
        abovetext+=$'\n'"- This app installs these packages: <b>$(sed 's/ /, /g' <<<"$packages")</b>"
      fi
    fi
    
    #show app's website if available
    if [ -f "${DIRECTORY}/apps/${app}/website" ];then
      website="$(head -n1 "${DIRECTORY}/apps/${app}/website")"
      abovetext+=$'\n'"- Website: <a href="\""$website"\"">$website</a>"
      
      #show credits link if available - on same line as website link
      if [ -f "${DIRECTORY}/apps/${app}/credits" ];then
        abovetext+=" | <a href="\""file://${DIRECTORY}/apps/${app}/credits"\"">Credits</a>"
      fi
      
    else #website unavailable
      #show credits link standalone, if available
      if [ -f "${DIRECTORY}/apps/${app}/credits" ];then
        abovetext+=$'\n'"- <a href="\""file://${DIRECTORY}/apps/${app}/credits"\"">Credits</a>"
      fi
    fi
    
    num_users="$(usercount "$app")"
    if [ ! -z "$num_users" ] && [ "$num_users" -gt 20 ];then
      #list the number of users, using this printf command to add commas (,) for every thousand number
      abovetext+=$'\n'"- <b>$(printf "%'d" "$num_users")</b> users"
      
      if [ "$num_users" -ge 10000 ];then
        #if this app has over 10,000 users, add two exclamation points!!
        abovetext+="!!"
      elif [ "$num_users" -ge 1500 ];then
        #if this app has over 1500 users, add an exclamation point!
        abovetext+="!"
      fi
    fi
    
    #array holding various buttons that may be passed to yad
    whichbutton=()
    
    if [ -f "${DIRECTORY}/apps/$app/uninstall" ] || [ -f "${DIRECTORY}/apps/$app/install" ] || [ -f "${DIRECTORY}/apps/$app/install-$arch" ];then
      whichbutton+=("--button=Scripts!${DIRECTORY}/icons/shellscript.png!Feel free to see how an app is installed!"$'\n'"Perfect for learning or troubleshooting.:6")
    fi
    if [ "$(cat "${DIRECTORY}/data/settings/Show Edit button")" == 'Yes' ];then
      #if edit button enabled, show it
      whichbutton+=("--button=Edit!${DIRECTORY}/icons/edit.png!Make changes to the app:8")
    fi
    
    #display buttons based on app's installation status
    if [ "$app_status" == 'installed' ];then
      #if installed, display uninstall button
      whichbutton+=("--button=Uninstall!${DIRECTORY}/icons/uninstall.png:2")
    elif [ "$app_status" == 'uninstalled' ];then
      #if uninstalled, display install button
      whichbutton+=("--button=Install!${DIRECTORY}/icons/install.png:4")
    elif [ "$app_status" == 'disabled' ];then
      #if disabled, display only an 'enable' button
      whichbutton+=("--button=<b>Enable</b>!!Force this app to install on your system."$'\n'"This app was disabled for a reason so if you enable it..."$'\n'"YOU HAVE BEEN WARNED.:12")
    else
      #if app status is 'corrupted', and a log file exists for this app, then display a button to view the log file
      if [ "$app_status" == 'corrupted' ];then
        logfile="$(ls "$DIRECTORY/logs"/* -t | grep "fail-${app}" | head -n1)"
        if [ ! -z "$logfile" ];then
          whichbutton+=("--button=Errors!${DIRECTORY}/icons/log-file.png!$app failed to $(echo "$(basename "$logfile")" | awk -F'-' '{print $1}'). Click this button to view the error output saved in the log file.:14")
        fi
      fi
      #if status is corrupted or unknown, then show both buttons
      whichbutton+=("--button=Uninstall!${DIRECTORY}/icons/uninstall.png:2" "--button=Install!${DIRECTORY}/icons/install.png:4")
    fi
    
    #only display app icon if it exists
    if [ -f "${DIRECTORY}/apps/${app}/icon-64.png" ];then
      imageline=(--image="${DIRECTORY}/apps/${app}/icon-64.png" --image-on-top)
    fi
    
    #Make sure app details window is focused (necessary for openbox window manager)
    (i=0
      while [ "$(xdotool getactivewindow getwindowname)" != "Details of ${app}" ] && [ $i -lt 20 ]; do
        wmctrl -a "Details of ${app}" #Raise the window named "Details of ${app}"
        sleep 0.2
        i=$((i+1))
      done) &
    
    #display app details window
    (cat "${DIRECTORY}/apps/$app/description" || echo "Description unavailable") | yad --text-info --fontname=12 --wrap --show-uri \
      --text="$(sed 's/&/&amp;/g' <<<"$abovetext")" \
      "${imageline[@]}" \
      --title="Details of ${app}" --window-icon="${DIRECTORY}/icons/logo.png" \
      $geometry2 --close-on-unfocus --skip-taskbar \
      "${whichbutton[@]}"
    button=$?
    
    case $button in
    4)
      #install
      terminal_manage install "$app"
      ;;
    2)
      #uninstall
      terminal_manage uninstall "$app"
      ;;
    6)
      #scripts
      install_script="${DIRECTORY}/apps/${app}/$(script_name_cpu "$app")"
      uninstall_script="${DIRECTORY}/apps/${app}/uninstall"
      
      text_editor "$uninstall_script" &
      sleep 0.1
      text_editor "$install_script" &
      
      "${DIRECTORY}/gui" "$@" #open details window again
      ;;
    8)
      #edit
      "${DIRECTORY}/createapp" "$app"
      refresh_list
      ;;
    12)
      #enable
      
      #remove status file containing 'disabled'
      rm -f "${DIRECTORY}/data/status/${app}"
      refresh_list &
      "${DIRECTORY}/gui" "$@" #open details window again
      ;;
    14)
      #viewlog
      echo "Viewing error log of $app..."
      echo "Log filepath: $logfile"
      "${DIRECTORY}/etc/viewlog" "$logfile"
      
      "${DIRECTORY}/gui" "$@" #open details window again
      ;;
    *)
      #unknown button
      exit 0
      ;;
    esac
    
  fi
  exit 0
fi

DIRECTORY="$(readlink -f "$(dirname "$0")")"

set -a #make all functions in the api available to subprocesses
source "${DIRECTORY}/api" || error "failed to source ${DIRECTORY}/api"

#display the pi-apps logo in the terminal
generate_logo &

#Various stuff to run in background (enclosed in brackets so Geany IDE can collapse the code)
{

#check for updates
mkdir -p "${DIRECTORY}/data/status" "${DIRECTORY}/data/update-status"
"${DIRECTORY}/updater" set-status &>/dev/null &
trap "kill $! &>/dev/null" EXIT #kill the above subprocess on exit

#check mission-critical scripts and re-download them if they contain a syntax error
(
  sleep 10
  command -v shellcheck >/dev/null || exit 0
  
  if shellcheck "${DIRECTORY}/updater" --color=always | grep '\[31m' --before 1 ;then
    echo "Downloading updater script to repair syntax error"
    errors="$(wget -O "${DIRECTORY}/updater" 'https://raw.githubusercontent.com/Botspot/pi-apps/master/updater' 2>&1)" || echo "$errors"
  fi | sed 's/]31m//g'
  
  if shellcheck "${DIRECTORY}/api" --color=always | grep '\[31m' --before 1 ;then
    echo "Downloading api script to repair syntax error"
    errors="$(wget -O "${DIRECTORY}/api" 'https://raw.githubusercontent.com/Botspot/pi-apps/master/api' 2>&1)" || echo "$errors"
  fi | sed 's/]31m//g'
) &

#runonce entries
(
#remove contents of ${DIRECTORY}/data/preload
runonce <<"EOF"
  rm -rf  "${DIRECTORY}/data/preload"
EOF

#mark wine and box86 as disabled, if twisteros
runonce <<"EOF"
  if [ -f /usr/local/bin/twistver ] && command -v wine >/dev/null ;then
    echo 'disabled' > "${DIRECTORY}/data/status/Wine (x86)"
  fi
  if [ -f /usr/local/bin/twistver ] && command -v box86 >/dev/null ;then
    echo 'disabled' > "${DIRECTORY}/data/status/Box86"
  fi
EOF

#re-run install script on twistos lite to re-show some previously hidden apps
runonce <<"EOF"
if [ -f /usr/local/bin/twistver ] && [[ "$(twistver)" != 'Twister OS version'* ]];then
  "${DIRECTORY}/install"
fi
EOF

#remove old apps and migrate chromium downgrading apps to the new "Downgrade Chromium" app
runonce <<"EOF"
  #rework chromium downgrading apps to one single new app: 'Downgrade Chromium'
  rm -rf "${DIRECTORY}/apps/Back to Chromium v86"
  rm -rf "${DIRECTORY}/apps/Back to Chromium v78"
  if [ "$(cat "${DIRECTORY}/data/status/Back to Chromium v78" 2>/dev/null)" == installed ] || [ "$(cat "${DIRECTORY}/data/status/Back to Chromium v86" 2>/dev/null)" == installed ];then
    echo "installed" > "${DIRECTORY}/data/status/Downgrade Chromium"
  fi
  
  rm -rf "${DIRECTORY}/apps/FreeCAD (precompiled)"
  rm -rf "${DIRECTORY}/apps/Chromium Media Edition"
  rm -rf "${DIRECTORY}/apps/Cordless"
  rm -rf "${DIRECTORY}/apps/Retropie"
  
  #remove TBOPlayer if it's not already successfully installed
  if [ "$(app_status TBOPlayer)" != 'installed' ];then
    rm -rf "${DIRECTORY}/apps/TBOPlayer"
  fi
  
  #rename 'Turbo Scratch' app to 'Turbowarp'
  rm -rf "${DIRECTORY}/apps/Turbo Scratch"
  mv -f "${DIRECTORY}/data/status/Turbo Scratch" "${DIRECTORY}/data/status/Turbowarp" 2>/dev/null
  
  #rename 'Pi-Apps Terminal Plugin' app to 'Pi-Apps Terminal Plugin (python)'
  rm -rf "${DIRECTORY}/apps/Pi-Apps Terminal Plugin"
  mv -f "${DIRECTORY}/data/status/Pi-Apps Terminal Plugin" "${DIRECTORY}/data/status/Pi-Apps Terminal Plugin (python)" 2>/dev/null
  
  #rename 'Whatsapp' app to 'WhatsApp'
  rm -rf "${DIRECTORY}/apps/Whatsapp"
  mv -f "${DIRECTORY}/data/status/Whatsapp" "${DIRECTORY}/data/status/WhatsApp" 2>/dev/null
  
  #rename 'Sonic Pi 3.2' to 'Sonic Pi'
  rm -rf "${DIRECTORY}/apps/Sonic Pi 3.2"
  mv -f "${DIRECTORY}/data/status/Sonic Pi 3.2" "${DIRECTORY}/data/status/Sonic Pi" 2>/dev/null
  
  
  #rename 'Min Browser' to 'Min'
  rm -rf "${DIRECTORY}/apps/Min Browser"
  mv -f "${DIRECTORY}/data/status/Min Browser" "${DIRECTORY}/data/status/Min" 2>/dev/null
  
  #rename 'Pale Moon Browser' to 'Pale Moon'
  rm -rf "${DIRECTORY}/apps/Pale Moon Browser"
  mv -f "${DIRECTORY}/data/status/Pale Moon Browser" "${DIRECTORY}/data/status/Pale Moon" 2>/dev/null
  
  #rename 'Puffin Browser Demo' to 'Puffin'
  rm -rf "${DIRECTORY}/apps/Puffin Browser Demo"
  mv -f "${DIRECTORY}/data/status/Puffin Browser Demo" "${DIRECTORY}/data/status/Puffin" 2>/dev/null
  
  #rename 'Quartz Browser' to 'Quartz'
  rm -rf "${DIRECTORY}/apps/Quartz Browser"
  mv -f "${DIRECTORY}/data/status/Quartz Browser" "${DIRECTORY}/data/status/Quartz" 2>/dev/null
  
  #rename 'Tor Browser' to 'Tor'
  rm -rf "${DIRECTORY}/apps/Tor Browser"
  mv -f "${DIRECTORY}/data/status/Tor Browser" "${DIRECTORY}/data/status/Tor" 2>/dev/null
  
  #rename 'KeePassX' to 'KeePassXC'
  rm -rf "${DIRECTORY}/apps/KeePassX"
  mv -f "${DIRECTORY}/data/status/KeePassX" "${DIRECTORY}/data/status/KeePassXC" 2>/dev/null
  
  true
EOF

#rename xlunch setting to xlunch-dark
runonce <<"EOF"
  if [ "$(cat "${DIRECTORY}/data/settings/App List Style")" == xlunch ];then
    echo 'xlunch-dark' > "${DIRECTORY}/data/settings/App List Style"
  fi
EOF

#install dependencies
runonce <<"EOF"
  dependencies='yad curl wget aria2 lsb-release apt-utils imagemagick bc librsvg2-bin locales shellcheck git wmctrl xdotool'
  # Install dependencies if necessary
  if ! dpkg -s $dependencies >/dev/null 2>&1; then
    sudo apt install $dependencies -y -f --no-install-recommends
  fi
EOF

#transition from box86-no-binfmt-restart package to box86
runonce <<"EOF"
  if dpkg -l box86-no-binfmt-restart &>/dev/null ;then
    sudo dpkg --remove box86-no-binfmt-restart pi-apps-5f3374a7 && sudo apt update && sudo apt install box86 -y
  fi
  
  #if box86 is supposedly installed, but box86 command not found, reinstall box86
  if [ "$(app_status Box86)" == 'installed' ] && ! command -v box86 >/dev/null;then
    rm -f "${DIRECTORY}/data/status/Box86"
    "${DIRECTORY}/manage" uninstall Box86
    "${DIRECTORY}/manage" install Box86
  fi
  true
EOF

#remove files from pi-apps folder that are no longer used
runonce <<"EOF"
  rm -f "${DIRECTORY}/etc/bitlylink"
  rm -rf "${DIRECTORY}/data/categories"
EOF

#regenerate package-app status for one-time migration
runonce <<"EOF"
  IFS=$'\n'
  for app in $(list_apps package) ;do
    rm -f "${DIRECTORY}/data/status/${app}" || exit 1
  done
  
  refresh_all_pkgapp_status
EOF

#change settings icon
runonce <<"EOF"
  [ -a "$HOME/.local/share/applications/pi-apps-settings.desktop" ] && sed -i "s/logo.png/settings.png/g" "$HOME/.local/share/applications/pi-apps-settings.desktop" || true
EOF

#recompile xlunch for existing users because icons are rendered differently now. See: https://github.com/Tomas-M/xlunch/issues/129#issuecomment-1051006971
runonce <<"EOF"
  if [ -d "${DIRECTORY}/xlunch" ];then
    rm -rf "${DIRECTORY}/xlunch"
  fi
EOF

) &
}

#Determine the app list mode. Allowed values: 'yad-*', 'xlunch-*'
guimode="$(cat "${DIRECTORY}/data/settings/App List Style")"
[ -z "$guimode" ] && guimode=yad-default

#In YAD mode, two windows are handled in a side-by-side configuration. As a group, they must be centered on the the screen.
#In Xlunch mode, the window must be centered, but xlunch only handles absolute offsets.
{
  #determine screen_width and screen_height
  screen_dimensions="$(xrandr --nograb --current | awk -F 'connected |\\+|\\('  '/ connected.*[0-9]+x[0-9]+\+/ && $2 {printf $2 ", "}' | sed -n -e 's/^.*primary //p' | tr 'x+' ' ' | tr ',+' ' ')"
  if [ -z "$screen_dimensions" ];then
    # if screen_dimensions is empty, this could be a single monitor wayland display which does not have the word "primary" in the output
    # workaround is to get the first output returned for the connected display
    screen_dimensions="$(xrandr --nograb --current | awk -F 'connected |\\+|\\('  '/ connected.*[0-9]+x[0-9]+\+/ && $2 {printf $2 ", "}' | tr 'x+' ' ' | tr ',+' ' ')"
  fi
  screen_width="$(awk '{print $1}' <<<"$screen_dimensions")"
  screen_height="$(awk '{print $2}' <<<"$screen_dimensions")"
  unset screen_dimensions
  
  if [[ "$guimode" == yad* ]];then
    #total dimensions for both yad windows side by side
    height=400
    width=600
    #how far down from the top of screen should both windows be?
    yoffset=$(((screen_height/2)-(height/2)))
    
    #width of first window
    width1=250
    #width of second window
    width2=$((width - width1))
    
    #screen offsets for window 1
    xoffset1=$(((screen_width/2)-(width/2)))
    #screen offsets for window 2
    xoffset2=$(((screen_width/2)-(width/2)+width1))
    
    #set completed location arguments for both yad windows
    geometry1="--geometry=${width1}x${height}+${xoffset1}+${yoffset}"
    geometry2="--geometry=${width2}x${height}+${xoffset2}+${yoffset}"
    
  elif [[ "$guimode" == xlunch* ]];then
    #desired dimensions for xlunch window
    height=700
    width=800
    #determine 
    xoffset=$(((screen_width/2)-(width/2)))
    yoffset=$(((screen_height/2)-(height/2)))
  else
    error "Unrecognized app list style '$guimode'!"
  fi
}

#Compile xlunch if required
if [[ "$guimode" == xlunch* ]] && ([ ! -d "${DIRECTORY}/xlunch" ] || [ ! -f /usr/bin/xlunch ]);then
  #signal files
  rm -f /tmp/xlunchfailed /tmp/xlunchfinished /tmp/terminalexit
  echo '' > /tmp/terminalexit
  "${DIRECTORY}/etc/terminal-run" "
    function error {
      echo -e "\""\e[91m$1\e[39m"\""
      echo 'Close this terminal to exit.'
      echo '' > /tmp/xlunchfailed
      sleep infinity
    }
    trap 'echo "\"""\"" > /tmp/terminalexit' EXIT
    
    #uninstall xlunch first
    sudo rm -rf /etc/xlunch /usr/share/xlunch /usr/bin/xlunch /usr/bin/genentries /usr/bin/updateentries /usr/bin/genentries.desktop.sh /usr/share/icons/hicolor/48x48/apps/xlunch_ghost.png /usr/share/icons/hicolor/48x48/apps/xlunch.png /usr/share/applications/genentries.desktop
    
    rm -f /tmp/terminalexit
    sudo rm -rf /usr/bin/xlunch "\""$DIRECTORY/xlunch"\"" 2>/dev/null
    sudo apt install -y libimlib2-dev libx11-dev || error 'APT failed to install libimlib2-dev and libx11-dev packages!'
    cd "\""$DIRECTORY"\""
    git clone https://github.com/Tomas-M/xlunch || error 'Failed to clone xlunch repository!'
    cd "\""$DIRECTORY/xlunch"\""
    echo 'Running make...'
    echo "\"""\$"(cat '${DIRECTORY}/xlunch/Makefile' | grep -v 'genentries \|cp -r svgicons/')"\"" > '${DIRECTORY}/xlunch/Makefile'
    make -j8 || error 'make command failed!'
    echo 'Running sudo make install...'
    sudo make install || error 'sudo make install failed!'
    sudo rm -f /usr/share/applications/genentries.desktop
    cd $HOME
    if [ ! -f /usr/bin/xlunch ];then
      error 'xlunch should be installed now, but /usr/bin/xlunch does not exist!'
    fi
    echo '' > /tmp/xlunchfinished
  " 'Compiling xlunch...'
  
  #if terminal doesn't start in 3 seconds, then /tmp/terminalexit will exist.
  sleep 3
  
  #check for an exit status code from the running terminal
  while true; do
    if [ -f /tmp/xlunchfinished ];then
      echo "xlunch finished installing."
      break
    elif [ -f /tmp/xlunchfailed ];then
      #revert back to yad
      echo 'yad-default' > "{DIRECTORY}/data/settings/App List Style"
      error "xlunch failed to compile!"
    elif [ -f /tmp/terminalexit ];then #if terminal doesn't start in 3 seconds, then /tmp/terminalexit will exist.
      #revert back to yad
      echo 'yad-default' > "{DIRECTORY}/data/settings/App List Style"
      error "The xlunch compilation terminal exited prematurely."
    else
      sleep 1
    fi
  done
fi

#Determine message of the day. If announcements file missing or over a day old, download it.
if [ ! -f "${DIRECTORY}/data/announcements" ] || [ ! -z "$(find "${DIRECTORY}/data/announcements" -mtime +1 -print)" ]; then
  wget https://raw.githubusercontent.com/Botspot/pi-apps-announcements/main/message -qO "${DIRECTORY}/data/announcements"
fi

if [[ "$guimode" == yad* ]];then
  
  #create a named pipe to send app list through to yad
  pipe="$(mktemp -u)" #get a random filename to work with
  mkfifo $pipe #make the named pipe
  trap "rm $pipe" EXIT #remove this named pipe on exit
  echo pipe is $pipe
  
  while true;do #main operating loop for yad window
    #in background process, send initial app list to yad; first echo line waits until yad is accepting input, then use small delay to prevent items from being missed
    (echo -e '\f' > $pipe
    sleep 0.5
    "${DIRECTORY}/preload" yad '' >> $pipe) &
    
    #retrieve a random line from the announcements file for this session
    motd="$(shuf -n 1 "${DIRECTORY}/data/announcements")"
    
    #constantly read from the pipe and send all output to yad
    #if an item is selected, this script will be run with the row's contents
    tail -F $pipe | yad --center --title='Pi-Apps' \
      --image="${DIRECTORY}/icons/logo-64.png" --image-on-top --text "$motd" \
      --list --no-headers --column=:IMG  --column=Name --column=Sysname:HD --column=tip:HD --column=@fore@:HD \
      --separator='\n' --window-icon="${DIRECTORY}/icons/logo.png" \
      --tooltip-column=4 \
      --dclick-action "env pipe=$pipe geometry2=$geometry2 '${DIRECTORY}/gui'" --select-action "env pipe=$pipe geometry2=$geometry2 '${DIRECTORY}/gui'" \
      --button="!${DIRECTORY}/icons/search.png"!'Search':"env pipe=$pipe geometry2=$geometry2 '${DIRECTORY}/gui' '' '' Search/ Search/" \
      --button="!${DIRECTORY}/icons/options.png"!'Settings':2 \
      "$geometry1"
    
    button=$? #get exit code of yad - indicates which button was clicked
    
    case $button in
    2) #settings
      "${DIRECTORY}/settings"
      "${DIRECTORY}/gui" "$@" #run new instance of this script
      exit 0
      ;;
      
    3) #search
      app="$(yadflags+=("$geometry2") ; app_search_gui)"
      
      if [ ! -z "$app" ];then
        "${DIRECTORY}/gui" '' '' "$app" "$app"
      fi
      ;;
    *) #unknown button
      exit 0
      ;;
    esac
  done
  #END of yad main window loop
  
elif [[ "$guimode" == xlunch* ]];then
  
  #create a named pipe to send app list through to yad
  pipe="$(mktemp -u)" #get a random filename to work with
  mkfifo $pipe #make the named pipe
  trap "rm $pipe" EXIT #remove this named pipe on exit
  echo pipe is $pipe
  
  #disabled, but too cool to remove: this can make the transparent background of xlunch blurry - like Windows 7
  if false;then
    scrot -a "$((xoffset+1)),$((yoffset+33)),${width},${height}" blur.png #blur_init.png
    convert -blur 10x5 ~/blur.png ~/blur.png
  fi
  
  #Depending on the xlunch theme, different arguments will be used.
  if [ "$guimode" == xlunch-light-3d ];then
    #light mode
    xlunchflags=(--multiple --dontquit -WoCS -s 64 --bc e0e0e000 --tc 000000 --pc 6060ffff --hc ffffff50 \
      -p "Search: " -a -c $([ $width -lt 550 ] && echo 1 || echo 2) --title "Pi-Apps: Raspberry Pi app store" \
      --icon "${DIRECTORY}/icons/logo.png" --scrollbarcolor ffffff40 --scrollindicatorcolor 0000ff80 \
      --width $width --height $height --xposition $xoffset --yposition $yoffset \
      --button "${DIRECTORY}/icons/logo-3d.png;;$((($width/2)-(300/2))),0;:exec echo pi-apps-homepage" \
      --button "${DIRECTORY}/icons/settings-dark.png;;$(($width-140)),30;:exec echo pi-apps-settings" \
      -g "${DIRECTORY}/icons/background-3d.png")
  elif [ "$guimode" == xlunch-dark-3d ];then
    #dark mode, 3d opaque version
    xlunchflags=(--multiple --dontquit -WoCS -s 64 --bc ffffff00 --tc DCDDDE --pc ffffffa0 --hc ffffff30 \
      -p "Search: " -a -c $([ $width -lt 550 ] && echo 1 || echo 2) --title "Pi-Apps: Raspberry Pi app store" \
      --icon "${DIRECTORY}/icons/logo.png" --scrollbarcolor ffffff20 --scrollindicatorcolor ffffff40 \
      --width $width --height $height --xposition $xoffset --yposition $yoffset \
      --button "${DIRECTORY}/icons/logo-3d-dark.png;;$((($width/2)-(300/2))),0;:exec echo pi-apps-homepage" \
      --button "${DIRECTORY}/icons/settings-light.png;;$(($width-140)),30;:exec echo pi-apps-settings" \
      -g "${DIRECTORY}/icons/background-3d-dark.png")
  else
    #dark mode, transparent version
    xlunchflags=(--multiple --dontquit -WoCS -s 64 --bc 000000A0 --tc ffffffff --pc 6060ffff --hc ffffff30 \
      -p "Search: " -a -c $([ $width -lt 550 ] && echo 1 || echo 2) --title "Pi-Apps: Raspberry Pi app store" \
      --icon "${DIRECTORY}/icons/logo.png" --scrollbarcolor ffffff40 --scrollindicatorcolor 0000ff80 \
      --width $width --height $height --xposition $xoffset --yposition $yoffset \
      --button "${DIRECTORY}/icons/logo-128.png;;$((($width/2)-(128/2))),0;:exec echo pi-apps-homepage" \
      --button "${DIRECTORY}/icons/logo-text.png;;$([ -z "$prefix" ] && echo '45' || echo '65'),$([ -z "$prefix" ] && echo '10' || echo '0');:exec echo pi-apps-homepage" \
      --button "${DIRECTORY}/icons/settings-light.png;;$(($width-140)),30;:exec echo pi-apps-settings")
  fi
  
  
  #in background process, send initial app list to xlunch; first echo line waits until xlunch is accepting input
  (
    #set initial value to make xlunch keep listening
    echo 'botspot is cool' > $pipe
    echo "$("${DIRECTORY}/preload" xlunch '')" > $pipe) &
  
  #read pipe      pipe to xlunch               read output of xlunch
  tail -F $pipe | xlunch "${xlunchflags[@]}" | while read -r line; do
    echo "Received '$line'"
    
    if [ "$line" == 'Updates/' ];then
      echo > $pipe #clear list
      
      #in subprocess, open details window for app
      geometry2="--center --height=$((height/2)) --width=$width" pipe='' "${DIRECTORY}/gui" '' '' "$line" "$line"
      
      #back to main level
      "${DIRECTORY}/preload" xlunch '' > $pipe
      
    #category selected
    elif [[ "$line" == */ ]];then
      echo > $pipe #clear list
      "${DIRECTORY}/preload" xlunch "$(echo "$line" | sed 's+/$++g')" > $pipe
      
    #pi-apps logo button clicked
    elif [ "$line" == 'pi-apps-homepage' ];then
      x-www-browser "$(cat "${DIRECTORY}/etc/git_url")" &
      
    #Settings button clicked
    elif [ "$line" == 'pi-apps-settings' ];then
      #close xlunch
      echo ':quit' > $pipe
      
      #run settings, then run pi-apps gui
      "${DIRECTORY}/settings"
      "${DIRECTORY}/gui" "$@"
      
      #exit this script
      exit 0
      
    #app selected
    else
      echo > $pipe #clear list
      
      #in subprocess, open details window for app
      geometry2="--center --height=$((height/2)) --width=$width" pipe='' "${DIRECTORY}/gui" '' '' "$line" "$line"
      
      #back to main level
      "${DIRECTORY}/preload" xlunch "$(dirname "$line" | sed 's/^.$//g')" > $pipe
    fi
  done
  
fi


